"""
Chat API helper functions and endpoint for Todo AI Chatbot.

Provides conversation and message retrieval logic for the chat endpoint
along with the main POST /api/{user_id}/chat endpoint.
All functions follow async patterns and enforce user data isolation.
"""

from logging import getLogger
from typing import Any, Dict, List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field, field_validator
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlmodel import select as sqlmodel_select

from datetime import datetime

from src.api.deps import get_current_user_id
from src.db.session import get_session
from src.models import Conversation, Message
from src.schemas import ChatRequest, ChatResponse as SchemaChatResponse, ToolCallDetail
from src.services.agent import execute_agent


# Configure logging
logger = getLogger(__name__)


# ============================================================================
# FastAPI Router
# ============================================================================

router = APIRouter()


# ============================================================================
# Type alias for backward compatibility
# ============================================================================

# Use the standardized schema from schemas.py
ChatRequest = ChatRequest
ChatResponse = SchemaChatResponse


# ============================================================================
# Conversation Management
# ============================================================================

async def get_or_create_conversation(
    session: AsyncSession,
    user_id: UUID,
    conversation_id: Optional[UUID] = None,
) -> Conversation:
    """
    Get existing conversation or create a new one for the user.

    This function implements the core conversation retrieval/creation logic:
    - If conversation_id provided: fetch and validate ownership
    - If conversation_id is None: create new conversation for user
    - Enforces user data isolation to prevent cross-user access

    Args:
        session: Async database session
        user_id: Authenticated user's UUID (from JWT token)
        conversation_id: Optional conversation UUID to retrieve

    Returns:
        Conversation object (existing or newly created)

    Raises:
        HTTPException: 404 if conversation_id not found or doesn't belong to user

    Example:
        # Continue existing conversation
        conv = await get_or_create_conversation(session, user_id, conversation_id)
        # Start new conversation
        conv = await get_or_create_conversation(session, user_id)
    """
    if conversation_id is not None:
        # Fetch existing conversation and validate ownership
        statement = sqlmodel_select(Conversation).where(
            Conversation.id == conversation_id
        )
        result = await session.execute(statement)
        conversation = result.scalar_one_or_none()

        # Validate conversation exists and belongs to user
        if conversation is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Conversation with ID {conversation_id} not found"
            )

        if conversation.user_id != user_id:
            # Security: Don't reveal conversation existence to other users
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Conversation not found"
            )

        return conversation

    else:
        # Create new conversation for user
        new_conversation = Conversation(user_id=user_id)
        session.add(new_conversation)
        await session.flush()  # Get the generated ID without committing

        return new_conversation


async def fetch_conversation_history(
    session: AsyncSession,
    conversation_id: UUID,
    limit: int = 50,
) -> List[Message]:
    """
    Fetch conversation message history from database.

    Retrieves all messages for the specified conversation in chronological order.
    Applies limit to prevent excessive memory usage for long conversations.

    Args:
        session: Async database session
        conversation_id: UUID of conversation to fetch messages for
        limit: Maximum number of messages to retrieve (default: 50)

    Returns:
        List of Message objects ordered by created_at (oldest first)

    Raises:
        HTTPException: 400 if limit is invalid (must be positive integer)
        ValueError: If limit exceeds maximum allowed (1000)

    Example:
        messages = await fetch_conversation_history(session, conv_id, limit=100)
        for msg in messages:
            print(f"{msg.role}: {msg.content}")
    """
    # Validate limit parameter
    if limit <= 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Limit must be a positive integer"
        )

    if limit > 1000:
        raise ValueError("Limit cannot exceed 1000 messages")

    # Fetch messages ordered by creation time (chronological order)
    statement = (
        sqlmodel_select(Message)
        .where(Message.conversation_id == conversation_id)
        .order_by(Message.created_at.asc())
        .limit(limit)
    )

    result = await session.execute(statement)
    messages = list(result.scalars().all())

    return messages


# ============================================================================
# Message Persistence Helper Functions
# ============================================================================

async def save_user_message(
    session: AsyncSession,
    conversation_id: UUID,
    user_id: UUID,
    content: str
) -> Message:
    """
    Save a user message to the database.

    Creates a new Message with role="user", persists it to the database,
    and returns the created message with generated id and timestamps.

    Args:
        session: Async database session
        conversation_id: UUID of the conversation
        user_id: UUID of the user (for data isolation)
        content: Message text content

    Returns:
        Message: Created message object with id and created_at populated

    Raises:
        HTTPException: 500 if database operation fails
        ValueError: If content is empty or invalid

    Example:
        >>> message = await save_user_message(session, conv_id, user_id, "Hello")
        >>> print(message.id, message.created_at)
        uuid.UUID('...'), datetime.datetime(...)
    """
    # Validate input
    if not content or not content.strip():
        raise ValueError("Message content cannot be empty")

    # Create new message with role="user"
    message = Message(
        conversation_id=conversation_id,
        user_id=user_id,
        role="user",
        content=content.strip()
    )

    try:
        # Add to session and commit
        session.add(message)
        await session.commit()
        # Refresh to get generated fields (id, created_at)
        await session.refresh(message)

        logger.info(
            f"Saved user message: id={message.id}, "
            f"conversation_id={conversation_id}, user_id={user_id}"
        )

        return message

    except SQLAlchemyError as e:
        # Rollback on error
        await session.rollback()
        logger.error(f"Database error saving user message: {str(e)}")
        raise RuntimeError(f"Failed to save user message: {str(e)}") from e


async def save_assistant_message(
    session: AsyncSession,
    conversation_id: UUID,
    user_id: UUID,
    content: str
) -> Message:
    """
    Save an assistant message to the database.

    Creates a new Message with role="assistant", persists it to the database,
    and returns the created message with generated id and timestamps.

    Args:
        session: Async database session
        conversation_id: UUID of the conversation
        user_id: UUID of the user (for data isolation)
        content: Message text content

    Returns:
        Message: Created message object with id and created_at populated

    Raises:
        HTTPException: 500 if database operation fails
        ValueError: If content is empty or invalid

    Example:
        >>> message = await save_assistant_message(session, conv_id, user_id, "Hi!")
        >>> print(message.id, message.created_at)
        uuid.UUID('...'), datetime.datetime(...)
    """
    # Validate input
    if not content or not content.strip():
        raise ValueError("Message content cannot be empty")

    # Create new message with role="assistant"
    message = Message(
        conversation_id=conversation_id,
        user_id=user_id,
        role="assistant",
        content=content.strip()
    )

    try:
        # Add to session and commit
        session.add(message)
        await session.commit()
        # Refresh to get generated fields (id, created_at)
        await session.refresh(message)

        logger.info(
            f"Saved assistant message: id={message.id}, "
            f"conversation_id={conversation_id}, user_id={user_id}"
        )

        return message

    except SQLAlchemyError as e:
        # Rollback on error
        await session.rollback()
        logger.error(f"Database error saving assistant message: {str(e)}")
        raise RuntimeError(f"Failed to save assistant message: {str(e)}") from e


# ============================================================================
# Message Formatting for OpenAI Agents SDK
# ============================================================================

def format_messages_for_agent(messages: List[Message]) -> List[dict]:
    """
    Convert list of Message objects to OpenAI format for agent input.

    Transforms database Message objects into the format expected by OpenAI
    Agents SDK: [{"role": "user"|"assistant", "content": "..."}].

    Preserves chronological order (oldest to newest) as returned from database.
    Handles empty message lists gracefully by returning empty list.

    Args:
        messages: List of Message objects from database query.
                  Messages should be ordered by created_at ASC.

    Returns:
        List of dictionaries in OpenAI message format:
        [
            {"role": "user", "content": "first message"},
            {"role": "assistant", "content": "response"},
            {"role": "user", "content": "follow up"}
        ]

    Examples:
        >>> messages = [Message(role="user", content="Hello"), Message(role="assistant", content="Hi there")]
        >>> format_messages_for_agent(messages)
        [{'role': 'user', 'content': 'Hello'}, {'role': 'assistant', 'content': 'Hi there'}]

        >>> format_messages_for_agent([])
        []
    """
    # Handle empty list
    if not messages:
        return []

    # Convert each message to OpenAI format
    formatted = []
    for message in messages:
        formatted.append({
            "role": message.role,
            "content": message.content
        })

    return formatted


def truncate_history_to_max(messages: List[dict], max_tokens: int = 8000) -> List[dict]:
    """
    Truncate conversation history to fit within token limit.

    Implements simple truncation strategy:
    - Removes oldest messages first (keeps most recent context)
    - Always keeps at least the 10 most recent messages (minimum context window)
    - Uses approximate character count (assumes ~4 characters per token)

    This is a basic implementation; production systems might use more
    sophisticated tokenization (e.g., tiktoken) for precise counting.

    Args:
        messages: List of formatted message dictionaries (from format_messages_for_agent)
        max_tokens: Maximum tokens allowed (default: 8000 for typical context windows)

    Returns:
        Truncated list of messages within token limit, preserving chronological order.
        Always returns at least the 10 most recent messages if available.

    Examples:
        >>> messages = [{"role": "user", "content": "A" * 1000}] * 50  # 50k characters
        >>> truncated = truncate_history_to_max(messages, max_tokens=2000)
        >>> len(truncated)  # Keeps most recent messages to fit ~8000 chars
        8

        >>> # Keeps minimum 10 messages even if slightly over limit
        >>> short_messages = [{"role": "user", "content": "Hi"}] * 15
        >>> truncate_history_to_max(short_messages, max_tokens=10)
        15  # All 15 kept (minimum guarantee)
    """
    # Handle empty list
    if not messages:
        return []

    # Ensure we keep at least 10 most recent messages (minimum context)
    MINIMUM_MESSAGES = 10
    if len(messages) <= MINIMUM_MESSAGES:
        return messages

    # Approximate token limit in characters (~4 chars per token)
    max_chars = max_tokens * 4

    # Start from the end (most recent) and work backwards
    total_chars = 0
    truncated_indices = []

    for i in range(len(messages) - 1, -1, -1):
        message = messages[i]
        content_length = len(message.get("content", ""))

        # Check if adding this message exceeds limit
        # (but always ensure we keep at least MINIMUM_MESSAGES)
        messages_kept = len(truncated_indices)
        if messages_kept >= MINIMUM_MESSAGES and total_chars + content_length > max_chars:
            # Would exceed limit and we have minimum - stop here
            break

        # Keep this message
        truncated_indices.append(i)
        total_chars += content_length

    # Reverse to restore chronological order and slice messages
    truncated_indices.reverse()
    return [messages[i] for i in truncated_indices]


# ============================================================================
# Chat Endpoint
# ============================================================================

@router.post(
    "/api/{user_id}/chat",
    response_model=SchemaChatResponse,
    status_code=status.HTTP_200_OK,
    tags=["Chat"]
)
async def chat_endpoint(
    user_id: UUID,
    request: ChatRequest,
    token_user_id: UUID = Depends(get_current_user_id),
    session: AsyncSession = Depends(get_session),
):
    """
    POST /api/{user_id}/chat - Send a message and receive AI response (T035).

    This endpoint handles incoming chat messages by:
    1. Validating the JWT token and extracting user_id
    2. Ensuring the path user_id matches the token user_id
    3. Getting or creating a conversation
    4. Saving the user message to the database
    5. Fetching conversation history
    6. Executing the AI agent with conversation context
    7. Saving the assistant's response to the database
    8. Returning formatted response with tool call details

    The endpoint integrates with OpenAI Agents SDK to provide AI-powered
    task management through natural language.

    Args:
        user_id: UUID from path parameter (must match JWT token)
        request: ChatRequest with conversation_id (optional) and message (required)
        token_user_id: UUID extracted from JWT token via dependency
        session: Async database session from dependency

    Returns:
        SchemaChatResponse with conversation_id, assistant_message, tool_calls, and timestamp

    Raises:
        HTTPException 403: If path user_id doesn't match token user_id
        HTTPException 404: If conversation_id not found or doesn't belong to user
        HTTPException 422: If message validation fails
        HTTPException 500: If agent execution or database operations fail

    Example Request:
        POST /api/123e4567-e89b-12d3-a456-426614174000/chat
        {
            "conversation_id": null,
            "message": "Add a task to buy groceries"
        }

    Example Response:
        {
            "conversation_id": "123e4567-e89b-12d3-a456-426614174000",
            "assistant_message": "I've added that task for you!",
            "tool_calls": [
                {
                    "tool_name": "add_task",
                    "arguments": {"title": "Buy groceries"},
                    "result": {"success": true, "data": {"id": 1}}
                }
            ],
            "timestamp": "2025-01-19T12:00:00Z"
        }
    """
    # Security: Verify path user_id matches token user_id
    # This prevents users from accessing other users' conversations
    if user_id != token_user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User ID in path does not match authenticated user"
        )

    # Step 1: Get or create conversation for the user
    conversation = await get_or_create_conversation(
        session=session,
        user_id=user_id,
        conversation_id=request.conversation_id
    )

    # Step 2: Save user message to database
    saved_message = await save_user_message(
        session=session,
        conversation_id=conversation.id,
        user_id=user_id,
        content=request.message
    )

    logger.info(
        f"Processing chat request: conversation_id={conversation.id}, "
        f"user_id={user_id}, message_length={len(saved_message.content)}"
    )

    try:
        # Step 3: Fetch conversation history for agent context
        conversation_history = await fetch_conversation_history(
            session=session,
            conversation_id=conversation.id,
            limit=50  # Last 50 messages for context
        )

        logger.debug(
            f"Retrieved {len(conversation_history)} messages from conversation history"
        )

        # Step 4: Execute AI agent with conversation context and new message
        agent_result = await execute_agent(
            user_id=user_id,
            conversation_history=conversation_history,
            message=request.message
        )

        # Step 5: Extract agent response and tool calls
        assistant_message = agent_result.get("assistant_message", "")
        tool_calls_raw = agent_result.get("tool_calls", [])

        # Step 6: Save assistant message to database
        await save_assistant_message(
            session=session,
            conversation_id=conversation.id,
            user_id=user_id,
            content=assistant_message
        )

        # Step 7: Format tool calls according to T035 schema
        formatted_tool_calls = []
        for tool_call in tool_calls_raw:
            formatted_tool_calls.append(ToolCallDetail(
                tool_name=tool_call.get("tool_name", "unknown"),
                arguments=tool_call.get("arguments", {}),
                result=tool_call.get("result")
            ))

        # Step 8: Build and return standardized response (T035)
        response = SchemaChatResponse(
            conversation_id=conversation.id,
            assistant_message=assistant_message,
            tool_calls=formatted_tool_calls,
            timestamp=datetime.utcnow()
        )

        logger.info(
            f"Chat endpoint successful: conversation_id={conversation.id}, "
            f"tool_calls_count={len(formatted_tool_calls)}, "
            f"response_length={len(assistant_message)}"
        )

        return response

    except ValueError as e:
        # Agent validation errors (e.g., empty message)
        logger.error(f"Validation error in chat endpoint: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid request: {str(e)}"
        )

    except RuntimeError as e:
        # Database or agent execution errors
        logger.error(f"Runtime error in chat endpoint: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to process chat message. Please try again later."
        )

    except Exception as e:
        # Unexpected errors
        logger.error(f"Unexpected error in chat endpoint: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected error occurred. Please try again later."
        )


# ============================================================================
# Exports
# ============================================================================

__all__ = [
    "router",
    "ChatRequest",
    "ChatResponse",
    "chat_endpoint",
    "get_or_create_conversation",
    "fetch_conversation_history",
    "save_user_message",
    "save_assistant_message",
    "format_messages_for_agent",
    "truncate_history_to_max",
]
